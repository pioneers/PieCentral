#!/usr/bin/env python3

import asyncio
import functools
import logging
import structlog
from typing import Mapping

import msgpack
import zmq
import zmq.asyncio
import click

import runtimeclient as runtime


logging.disable()
structlog.configure(
    processors=[structlog.stdlib.filter_by_level],
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
)


def catch_command_exc(cli):
    @functools.wraps(cli)
    def wrapper(*args, **kwargs):
        try:
            return cli(*args, **kwargs)
        except runtime.RuntimeClientError as exc:
            click.echo(click.style(str(exc), fg='red', bold=True))
    return wrapper


@click.group()
@click.option('--host', default='127.0.0.1')
@click.pass_context
def cli(ctx, host):
    """
    fctool -- Field control command-line interface
    """
    ctx.obj = ctx.obj or {}
    ctx.obj['host'] = host
    logging.getLogger().propogate = False


@cli.command('set-match')
@click.option('-m', '--mode', default='IDLE', help='Robot execution state',
              type=click.Choice(['IDLE', 'AUTO', 'TELEOP', 'ESTOP']))
@click.option('-a', '--alliance', default='BLUE', help='Robot alliance',
              type=click.Choice(['BLUE', 'GOLD']))
@click.pass_context
def set_match(ctx, mode, alliance):
    print(mode, alliance)


@cli.group()
def alias():
    pass


def display_aliases(aliases: Mapping[str, str]):
    if aliases:
        click.echo(click.style(f'{len(aliases)} aliases:', fg='green', bold=True))
        for name, uid in aliases.items():
            click.echo(f'  {name} -> {uid}')
    else:
        click.echo(click.style('No aliases', fg='yellow', bold=True))


@alias.command('list')
@click.pass_context
@catch_command_exc
def list_aliases(ctx):
    """ List all human-readable device aliases for UIDs. """
    with runtime.RuntimeClient(ctx.obj['host']) as client:
        aliases = client.send_command('list_aliases')
        display_aliases(aliases['aliases'])


@alias.command('set')
@click.argument('name')
@click.argument('uid')
@click.pass_context
@catch_command_exc
def set_alias(ctx, name, uid):
    """ Set a human-readable alias for a device UID. """
    with runtime.RuntimeClient(ctx.obj['host']) as client:
        aliases = client.send_command('set_alias', name, uid)
        click.echo('Successfully set alias!')
        display_aliases(aliases['aliases'])


@alias.command('del')
@click.argument('name')
@click.pass_context
@catch_command_exc
def del_alias(ctx, name):
    """ Delete a human-readable alias for a device UID. """
    with runtime.RuntimeClient(ctx.obj['host']) as client:
        aliases = client.send_command('del_alias', name)
        click.echo('Successfully deleted alias!')
        display_aliases(aliases['aliases'])


@cli.command('lint')
@click.pass_context
def lint(ctx, ch='#', side=25):
    socket = CONTEXT.socket(zmq.REQ)
    socket.connect(ctx.obj['cmd_addr'])
    socket.send(msgpack.packb({'type': 'lint'}))
    chunks, packet = socket.recv_multipart(), bytearray()
    for chunk in chunks:
        packet.extend(chunk)
    payload = msgpack.unpackb(packet, raw=False)
    socket.close()

    print(f'{ch*side} stdout {ch*side}', end='\n'*2)
    print(payload['stdout'].strip(), end='\n'*2)
    print(f'{ch*(8 + 2*side)}', end='\n'*3)
    print(f'{ch*side} stderr {ch*side}', end='\n'*2)
    print(payload['stderr'].strip(), end='\n'*2)
    print(f'{ch*(8 + 2*side)}')


@cli.command()
@click.pass_context
def log(ctx):
    # import zmq
    # ctx = zmq.Context()
    # socket = ctx.socket(zmq.SUB)
    # # socket.bind('ipc:///tmp/log2.sock')
    # socket.connect('tcp://127.0.0.1:6003')
    # socket.subscribe(b'')
    # print('Starting')
    # while True:
    #     print(socket.recv())

    with runtime.RuntimeClient(ctx.obj['host']) as client:
        while True:
            try:
                print(client.recv_log())
            except ValueError:
                click.echo(click.style('Failed to decode record', fg='red'))


if __name__ == '__main__':
    cli()
